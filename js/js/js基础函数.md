# js的基础-函数

> 函数: js中指的是实现某一个功能的方法

- 创建函数

 ```js
  function [函数名] ([形参]) {
    函数体：某个方法的具体实现
  }
 ```

- 函数封装的特点
  1. 提高代码功能的开发效率
  2. 降低代码的冗余度，低耦合高内聚

- JS中函数的核心原理

> 函数作为js中引用类型中的一种，也是按照引用类型的来存储的

- 函数的函数名在内存中存储在栈中，函数体中的代码是按照字符串存储在堆中的，然后在把引用的地址和函数名相关联,当函数执行的时候，函数名入栈，函数名执行会把地址指定会那堆中的函数体按照自上而下执行（函数没有执行，函数是没有意义的）
- 函数执行会形成一个私有作用域(只能执行函数中存储的代码)
  - 执行过程
    1. 形参赋值
    2. 变量提升
    3. 自上而下执行代码
    4. 私有作用域销毁的问题

- 闭包

> 函数执行会形成一个私有的作用域，让李密胺的私有作用域和外界互不干扰，此时我们可以理解为私有作用域把私有变量保护起来，这种保护机制就是**闭包**
> 对象在堆中存储是以键值对进行存储的，而函数是以字符串存储的

## 函数中的行参和实参

> 为函数提供了一个入口，用来存储和接收实参传递过来的值

```js
function fn(num1, num2) {  // num1, num2就是形参变量
}
```

- arguments实参集合
  1. arguments只有函数才有，
  2. 函数天生自带的
  3. arguments中始终存储的是实参信息
  4. arguments类数组(以数字做索引，具有length的属性)
- arguments.callee: 存储的是当前函数本身
- arguments.callee.calller: 存储的是当前宿主函数在哪执行的，在全局下执行结果是null,执行函数的执行环境

 ```js
 function fn () {
   var total = null
   for(var i = 1; i< arguments.length; i++) {
    var curr = Number(arguments[i])
    if (isNaN(curr)) {
      continue;
    }
    total += curr
   }
   return total  // return后面返回的都是值，而不是返回变量
 }
  ```

- 函数的返回值return
  - 直接返回return之后的代码都不在执行

- js中的匿名函数

> 函数表达式
> 自执行函数

```js
oBox.onclick = functions() {

}

(function(n) {
  创建函数和执行函数放在一起了，创建之后立马执行
})(10)
```